# -*- coding: utf-8 -*-
"""plot_functions

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fvsv20OqL60nKjM9_ak-zk_h9Eb8XA-y
"""

import os
import re
import sys
from itertools import compress
import random
import math
import numpy as np
import rioxarray
import matplotlib
from matplotlib.colors import LogNorm
from matplotlib.ticker import LogFormatter
from matplotlib.colors import LinearSegmentedColormap
import matplotlib.pyplot as plt
import xarray
from netCDF4 import num2date
import pandas as pd
import copy
import datetime
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
import seaborn as sns

import rasterio
import rasterio.warp
from rasterio.crs import CRS
from rasterio.plot import show
from shapely.geometry import box
import geopy.distance

import io
import imageio
from IPython.display import Image, display
from ipywidgets import widgets, Layout, HBox
import geopandas as gpd
from rasterio.plot import show
from great_circle_calculator.great_circle_calculator import *
from matplotlib_scalebar.scalebar import ScaleBar
from shapely.geometry import box

#import cv2
import adjustText as aT
import cmasher as cmr

"""# EDA Plots"""

def sample_density_plot(ds,
                        title_list = ["Tot Precipitation [mm]","Min Temp [K]","Max Temp [K]"],
                        saving_directory = None,
                        file_name = "empirical_densities",
                        width = 5, height = 10):

    """
    plot the sample densities for each variable stored in the XarrayDataset "ds"

    --- parameters ---

    "ds": xarray.Dataset
    "title_list": list of title to be plotted on each subplot
    "saving_directory": string, optional, path in which save the file
    "file_name": name of the file to be saved in "the saving_directory"
    "width", "height": numeric, width and height of the figure

    --- return ---
    it shows the plot
    """

    all_variables = list(ds.keys())
    fig, axes = plt.subplots(nrows=1, ncols=len(all_variables), figsize=(height, width))

    for i in range(len(all_variables)):
      ds[all_variables[i]].plot(ax = axes[i], density = True)
      axes[i].set_title(title_list[i])

    fig.tight_layout()

    if (saving_directory is not None):
      plt.savefig(saving_directory + file_name + '.png', dpi=400, bbox_inches = 'tight')
    else:
      return plt.show()

"""## Static map plots"""

## Define colormaps for the DTM ##

# Crop the terrain cmap to remove blue colors
cropped_cmap = cmr.get_sub_cmap(plt.cm.terrain, 0.2, 1.0)

# Create a greyscale version of a given colormap to display
# in a better way the DTM
def grayscale_cmap(cmap):
    """Return a grayscale version of the given colormap"""
    cmap = matplotlib.colormaps[cmap]
    colors = cmap(np.arange(cmap.N))

    # convert RGBA to perceived grayscale luminance
    # cf. http://alienryderflex.com/hsp.html
    RGB_weight = [0.299, 0.587, 0.114]
    luminance = np.sqrt(np.dot(colors[:, :3] ** 2, RGB_weight))
    colors[:, :3] = luminance[:, np.newaxis]

    return LinearSegmentedColormap.from_list(cmap.name + "_gray", colors, cmap.N)

def dtm_plot(dtm, cmap,
             inner_ticks = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 2000, 3000, 4000],
             ax = None,
             figure = None,
             title = ""):
  """
  plot function for dtm given a colormap and inner ticks of the color scale

  --- parameters ---

  "dtm": rasterio xarray object
  "cmap": a color map
  "ax": Axes object, optional, the axis on which disply the plot, if non a new axis is created
  "figure": Figure object, optional, the figure on which disply the ax, if non a new figure is created
  "title": str, title of the plot

  --- return ---
  it shows the plot
  """

  # Define the ticks
  cnorm = LogNorm(vmin=dtm.min(), vmax=dtm.max())
  decades = np.ceil(np.log10(cnorm.vmax / cnorm.vmin))
  formatter = LogFormatter(10, minor_thresholds=(decades, decades))

  # Plot with lognorm transformation
  # Define an axis if not provided
  if (ax is None and figure is None):
    figure, ax = plt.subplots()

  dtm_piemonte_plot = dtm.plot(ax = ax, cmap = cmap, add_colorbar=False,
                               norm = matplotlib.colors.LogNorm(vmin = cnorm.vmin, vmax = cnorm.vmax))
  # add min and max values
  inner_ticks.insert(0, cnorm.vmin)
  ticks = inner_ticks
  ticks.append(cnorm.vmax)
  ax.set_title(title)
  figure.colorbar(ticks=ticks, mappable=dtm_piemonte_plot,
                  format = formatter)

  return dtm_piemonte_plot

def plot_static_map(region_shapefile,
                    plot_title,
                    province_labels = None,
                    fontsize_province_label = 6.5,
                    province_coords = None,
                    dtm = None,
                    cmap = None,
                    inner_ticks = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 2000, 3000, 4000],
                    sensor_network_ds = None,
                    catchment_shapefile = None,
                    selected_catchment = None,
                    selected_sensors = None,
                    sensor_network_color = "dimgray",
                    selected_catch_color = "magenta",
                    selected_sensors_color = "tab:blue",
                    selected_sensors_edgecolor = "yellow",
                    point_markersize = 10,
                    point_linewidths = 0.2,
                    inset_object = None,
                    inset_bbox = [0,0,0.2,0.2],
                    ROI_box = None,
                    roi_color = "magenta",
                    write_sensor_labels = None,
                    fontsize_sensor_label = 9,
                    x_shift_sensor_labels = None,
                    y_shift_sensor_labels = None,
                    sensor_label_ha = 'center',
                    sensor_label_va='top',
                    map_bounds = False,
                    show_axes = False,
                    offset_legend = 0,
                    saving_path = None,
                    transparent = False,
                    spatial_resolution = None,
                    north_x_shift = 0.03,
                    north_y_shift = -0.2,
                    north_fontsize = 15,
                    arrow_dx = 0,
                    arrow_dy = 0.1,
                    arrow_x_shift = 0.1,
                    arrow_y_shift = -0.3,
                    arrow_head_width=0.08,
                    arrow_head_length=0.1):
    """
    Plot a map to display multiple static information, for example:
    DTM, sensor locations, selected sensors, ROI, catchments, selected catchment
    The plot could be zoomed or not on the ROI

    --- parameters ---

    "region_shapefile": GeoDataFrame shapefile of the region
    "plot_title": str, title of the plot
    "province_labels": list of str, optional, plot the label of object in the shapefile
    "fontsize_province_label": float, optional, font of the labels
    "province_coords" = list made of two element,  optional, in the first provide the longitued of the center of labels, in the second the latitudes
    "dtm": xarray, optional, dtm file rasterio xarray
    "cmap": optional, a color map for the dtm
    "inner_ticks": inner ticks of the cmap
    "sensor_network_ds": GeoDataFrame, optional, df with locations of sensors
    "catchment_shapefile": GeoDataFrame, optional, shapefile of the catchments
    "selected_catchment": GeoDataFrame, optional, shapefile of the selected catchment
    "selected_sensors": GeoDataFrame, optional, df with locations of the selected sensors
    "sensor_network_color": str, optional, color for the sensor network points
    "selected_catch_color": str, optional, color for the selected catchment boundaries
    "selected_sensors_color": str, optional, color for the selected sensors
    "selected_sensors_edgecolor": str, optional, edge color for the selected sensors. Default is "yellow"
    "point_markersize": float, optional, marker size for the sensor points
    "point_linewidths": float, optional, line width for the sensor points' edges
    "inset_object": GeoDataFrame, optional, shapefile of the map to be insert as an inset in the plot
    "inset_bbox": list, optional, bounding box for the inset map
    "ROI_box": box object, optional, coordinates defining the Region of Interest (ROI) box
    "roi_color": str, optional, color for the ROI box. Default is "magenta"
    "write_sensor_labels": list of str, optional, list of labels for the sensors
    "fontsize_sensor_label": float, optional, font size for the sensor labels
    "x_shift_sensor_labels": list of float, optional, x-axis manual shift values for sensor labels.
    "y_shift_sensor_labels": list of float, optional, y-axis manual shift values for sensor labels.
    "sensor_label_ha": str, optional, horizontal alignment for sensor labels
    "sensor_label_va": str, optional, vertical alignment for sensor labels
    "map_bounds": list of tuple [(xmin,xmax),(ymin,ymax)], optional, if None axes limits are set automatically
    "show_axes": bool, optional, whether to show the axes
    "offset_legend": float, optional, offset value for the legend
    "saving_path": str, optional, file path in which to save the plot. If None, the plot is displayed without saving
    "transparent": bool, optional, transparent in case of saving
    "spatial_resolution": float, optional, spatial resolution for the scale bar
    "north_x_shift": float, optional, x-axis shift for the N of North
    "north_y_shift": float, optional, y-axis shift for the N of North
    "north_fontsize": float, optional, font size for the N of North
    "arrow_dx": float, optional, x-axis length of the North arrow
    "arrow_dy": float, optional, y-axis length of the North arrow
    "arrow_x_shift": float, optional, x-axis shift for the North arrow
    "arrow_y_shift": float, optional, y-axis shift for the North arrow
    "arrow_head_width": float, optional, width of the North arrow head
    "arrow_head_length": float, optional, length of the North arrow head

    --- return ---
    it shows the plot and optionally it could save

    """
    fig, ax = plt.subplots()

    # DTM
    if (dtm is not None):
     elevation_map = dtm_plot(dtm, cmap,
                      inner_ticks = inner_ticks,
                      ax = ax,
                      figure = fig)

    # Regional shapefile
    region_shapefile.boundary.plot(color = 'Black', linewidth = 0.5, alpha = 0.6, ax = ax, label = "Administrative bounds")

    # If provinces labels and coordinates are given plot the labes
    if (all(check is not None for check in [province_labels, province_coords])):
      texts = []
      for x, y, label in zip(province_coords[0], province_coords[1], province_labels):

          texts.append(plt.text(x,y,label, ha='center', va='center' ,
                                fontsize = fontsize_province_label, fontweight = "bold", fontstyle = "italic", color = "Black")) #, fontsize = 8

          aT.adjust_text(texts, force_text =(0.1, 0.1), force_explode=(0, 0), #, min_arrow_len = 5
                       force_static =(0, 0),
                       arrowprops=dict(arrowstyle="simple", linestyle = "--", color='dimgrey', lw=1.2))

    # Sensor network
    if (sensor_network_ds is not None):
      all_sensors_map = sensor_network_ds.plot(color = sensor_network_color, ax = ax,
                                               markersize = point_markersize, edgecolors = selected_sensors_edgecolor,
                                               linewidths = point_linewidths,
                                               label="ARPA water table sensors")

    # Catchment shapefile
    if(catchment_shapefile is not None):
      catchment_map = catchment_shapefile.boundary.plot(color = "Blue", linewidth = 0.1, alpha = 1, ax = ax, label="III level catchments")

    # Selected catchment shapefile
    if (selected_catchment is not None):
      selected_catch_map = selected_catchment.boundary.plot(color = selected_catch_color, ls = '--', linewidth = 0.6, alpha = 1, ax = ax, label="Selected catchment")
    # ROI Box
    if (ROI_box is not None):
      ax.plot(*ROI_box, label = "Region of Interest (ROI)", color = roi_color)

    # Selected sensors
    if (selected_sensors is not None):
      selected_sens_map = selected_sensors.plot(color = selected_sensors_color, ax = ax,
                                                markersize = point_markersize, edgecolors = selected_sensors_edgecolor,
                                                linewidths = point_linewidths,
                                                label = "ARPA selected sensors")

      # Automatic adjustment of sensor's label
      if (write_sensor_labels is not None):
          if x_shift_sensor_labels is None and y_shift_sensor_labels is None:
            x_shift_sensor_labels = [0 for i in range(len(write_sensor_labels))]
            y_shift_sensor_labels = [0 for i in range(len(write_sensor_labels))]
          #texts = []
          for i in range(len(write_sensor_labels)):
            x_sens_label = selected_sensors.geometry.x.iloc[i] + selected_sensors.geometry.x.iloc[i]*x_shift_sensor_labels[i]
            y_sens_label = selected_sensors.geometry.y.iloc[i] + selected_sensors.geometry.y.iloc[i]*y_shift_sensor_labels[i]
            plt.text(x_sens_label, y_sens_label, write_sensor_labels[i], ha=sensor_label_ha, va=sensor_label_va ,
                                  fontsize = fontsize_sensor_label, fontweight = "bold", fontstyle = "italic", color = "Black") #, fontsize = 8

            # aT.adjust_text(texts, force_text = force_text_sensor_label, force_explode = force_explode_sensor_label, #
            #             force_static = force_static_sensor_label, force_pull = force_pull_sensor_label) #

    cbar_label = ''
    fig.suptitle(plot_title, x = 0.45, y = 0.925) # /OR/ x = (fig.subplotpars.right+0.15 + fig.subplotpars.left)/2

    # Plot the scale of the raster
    if (spatial_resolution is not None):
      ax.add_artist(ScaleBar(dx=spatial_resolution, units="m", frameon = False, location = "lower right"))

    #
    if (map_bounds is not None):
      # For zooming onto a specific area different from the extent of the
      # meteorological_raster
      ax.set_xlim(map_bounds[0])
      ax.set_ylim(map_bounds[1])

    if (show_axes == False):
      ax.set_axis_off()

    else:
      ax.tick_params(axis='x', rotation=50)
      ax.set(xlabel = "Longitude [째E]", ylabel = "Latitude [째N]")

    fig.legend(bbox_to_anchor=(0.6, 0.125 + offset_legend))  #  (x, y, width, height)

    # Inset maps
    if (inset_object is not None):
      axins = ax.inset_axes(bounds = inset_bbox)
      inset_object[0].boundary.plot(ax = axins, color = 'gray', linewidth = 0.5) # Italy
      axins.plot(*inset_object[1], color = "black") # Piemonte
      axins.set_xticks([])
      axins.set_yticks([])

    # Insert the North arrow
    ax.text(x=ax.get_xlim()[0]+north_x_shift, y=ax.get_ylim()[1]+north_y_shift, s='N', fontsize=north_fontsize)
    ax.arrow(ax.get_xlim()[0]+arrow_x_shift, ax.get_ylim()[1]+arrow_y_shift, arrow_dx, arrow_dy, length_includes_head=True,
          head_width=arrow_head_width, head_length=arrow_head_length, overhang=.1, facecolor='k')

    # For saving
    if (saving_path is not None):
      plt.savefig(saving_path, dpi=400, bbox_inches = 'tight', transparent = transparent)
    else:
      return plt.show()

"""## Statistic map plots"""

def compute_and_plot_map_statistics(meteo_dataset, statistic, var_name, ax, cmap, vmin, vmax):
  '''
  To compute and plot map statistics: per-pixel aggregation over time, the spatial
  dimension is untouched

  --- parameters ---

  "meteo_dataset": xarray dataset
  "statistic": str, statistic to be computed, available statistics: mean, median, max, min, std
  "var_name": str, variable of the dataset on which compute the statistic
  "ax": Axes object, axis on which to display the plot
  "cmap": a color map
  "vmin": minimum value for the color scale
  "vmax": maximum value for the color scale

  --- return ---
  it outputs the plot object
  '''
  if statistic == "Mean":
    map = meteo_dataset[var_name].mean(dim="time",skipna = True).plot(ax=ax, cmap = cmap, vmin = vmin, vmax = vmax, add_colorbar=False)
  elif statistic == "Median":
    map = meteo_dataset[var_name].median(dim="time",skipna = True).plot(ax=ax, cmap = cmap, vmin = vmin, vmax = vmax, add_colorbar=False)
  elif statistic == "Max":
    map = meteo_dataset[var_name].max(dim="time",skipna = True).plot(ax=ax, cmap = cmap, vmin = vmin, vmax = vmax, add_colorbar=False)
  elif statistic == "Min":
    map = meteo_dataset[var_name].min(dim="time",skipna = True).plot(ax=ax, cmap = cmap, vmin = vmin, vmax = vmax, add_colorbar=False)
  elif statistic == "Standard Deviation":
    map = meteo_dataset[var_name].std(dim="time",skipna = True).plot(ax=ax, cmap = cmap, add_colorbar=False)

  return map


def stat_map_plots(meteorological_raster, variable, region_shapefile, sensor_network_ds,
                   catchment_shapefile, selected_catchment, plot_title,
                   cmap, statistic = ["Mean", "Median", "Max", "Min", "Standard Deviation"],
                   vmin = None, vmax = None, selected_catch_color = "Magenta", map_bounds = None,
                   saving_path = None, file_name_add = "",
                   shrink_colorbar = 0.3, width = 18, height = 10): #variables: 0 "tot_prec", 1 "min_temp", 2 "max_temp" ; cmap: GnBu, Blues, Purples
  '''
  Plot multiple map statistics for the same variable, per-pixel aggregation though time is performed to compute the statistics

  --- parameters ---

  "meteorological_raster":  xarray.Dataset
  "variable": str, variable of the dataset on which compute the statistic
  "region_shapefile": GeoDataFrame shapefile of the region
  "sensor_network_ds": GeoDataFrame, df with locations of sensors
  "catchment_shapefile": GeoDataFrame, optional, shapefile of the catchments
  "selected_catchment": GeoDataFrame, optional, shapefile of the selected catchment
  "plot_title": str, title of the plot
  "cmap": a color map
  "statistic": list of string, statistics to be computed, available statistics: mean, median, max, min, std
  "map_bounds": list of tuple [(xmin,xmax),(ymin,ymax)], optional, if None axes limits are set automatically
  "vmin": float, optional, minimum value for the color scale
  "vmax": float, optional, maximum value for the color scale
  "saving_path": str, optional, file path in which to save the plot. If None, the plot is displayed without saving. Suggested: .../+ variable + '_map_statistics' + note_name + '.png'
  "file_name_add": str, optional, additional string to add to the file name
  "shrink_colorbar": float, shrinkage parameter for the colorbar
  "width", "height": float, width and height of the figure

  --- return ---
  it shows the plot and optionally it could save
  '''
  total_statistics = len(statistic)

  fig, img_stat = plt.subplots(1,total_statistics, figsize = (width,height) )
  fig.suptitle(plot_title, y=0.70)


  for i in range(total_statistics):
    # Regional shapefile
    region_borders = region_shapefile.boundary.plot(color = 'Black', linewidth = 0.8, alpha = 1, ax = img_stat[i], label="Administrative bounds" if i == 0 else "")
    # Statistic map
    statistic_map = compute_and_plot_map_statistics(meteorological_raster, statistic = statistic[i], var_name = variable, ax = img_stat[i] , cmap = cmap, vmin = vmin, vmax = vmax)
    # Sensor network
    all_sensors_map = sensor_network_ds.plot(color = "darkred", ax = img_stat[i], markersize = 5, label="ARPA water table sensors" if i == 0 else "")
    # Catchment shapefile
    catchment_map = catchment_shapefile.boundary.plot(color = "Blue", linewidth = 0.1, alpha = 1, ax = img_stat[i], label="III level catchments" if i == 0 else "")
    # Selected catchment shapefile
    sel_catc = selected_catchment.boundary.plot(color = selected_catch_color,ls = '--', linewidth = 0.4, alpha = 1, ax = img_stat[i], label="Selected catchment" if i == 0 else "")
    # Colorbar and title
    fig.colorbar(statistic_map, ax=img_stat[i], shrink = shrink_colorbar, extend = 'both')
    img_stat[i].set_title(statistic[i])

    if (map_bounds is not None):
    # For zooming onto a specific area different from the extent of the
    # meteorological_raster
      img_stat[i].set_xlim(map_bounds[0])
      img_stat[i].set_ylim(map_bounds[1])

    # Do not show axes
    img_stat[i].set_axis_off()


  fig.legend(bbox_to_anchor=(0.55, 0.35))  # bbox_to_anchor=(0.6, 0.1)  (x, y, width, height)
  # , label = "Administrative bounds", "III level catchments", "ARPA sensors", "Selected catchments"
  # [bords, Astat, catc, sel_catc], ["Administrative bounds", "III level catchments", "ARPA sensors", "Selected catchments"],


  if (saving_path is not None):
    plt.savefig(saving_path + variable + '_map_statistics' + file_name_add + '.png', dpi=400, bbox_inches = 'tight')
    #plt.close("all")
  else:
    return plt.show()

"""## Raster map plots"""

def plot_map_at_a_time_step(meteorological_raster, variable, time_step, region_shapefile,
                            cmap, plot_title,
                            vmin = None,
                            vmax = None,
                            sensor_network_ds = None,
                            catchment_shapefile = None,
                            selected_catchment = None,
                            selected_sensors = None,
                            sensor_network_color = "dimgray",
                            selected_catch_color = "magenta",
                            selected_sensors_color = "tab:blue",
                            selected_sensors_edgecolor = "yellow",
                            point_markersize = 10,
                            point_linewidths = 0.2,
                            write_sensor_labels = None,
                            map_bounds = False,
                            show_axes = False,
                            offset_legend = 0,
                            saving_path = None,
                            file_name_add = "",
                            transparent = False,
                            spatial_resolution = None,
                            north_x_shift = 0.03,
                            north_y_shift = -0.2,
                            north_fontsize = 15,
                            arrow_dx = 0,
                            arrow_dy = 0.1,
                            arrow_x_shift = 0.1,
                            arrow_y_shift = -0.3,
                            arrow_head_width=0.08,
                            arrow_head_length=0.1):
    """
    Plot a time-instance of a variable of a xarray dataset

    --- parameters ---

    "meteorological_raster":  xarray.Dataset
    "variable": str, variable of the dataset on which compute the statistic
    "region_shapefile": GeoDataFrame shapefile of the region
    "cmap": a color map
    "plot_title": str, title of the plot
    "vmin": float, optional, minimum value for the color scale
    "vmax": float, optional, maximum value for the color scale
    "sensor_network_ds": GeoDataFrame, optional, df with locations of sensors
    "catchment_shapefile": GeoDataFrame, optional, shapefile of the catchments
    "selected_catchment": GeoDataFrame, optional, shapefile of the selected catchment
    "selected_sensors": GeoDataFrame, optional, df with locations of the selected sensors
    "sensor_network_color": str, optional, color for the sensor network points
    "selected_catch_color": str, optional, color for the selected catchment boundaries
    "selected_sensors_color": str, optional, color for the selected sensors
    "selected_sensors_edgecolor": str, optional, edge color for the selected sensors. Default is "yellow"
    "point_markersize": float, optional, marker size for the sensor points
    "point_linewidths": float, optional, line width for the sensor points' edges
    "write_sensor_labels": list of str, optional, list of labels for the sensors
    "map_bounds": list of tuple [(xmin,xmax),(ymin,ymax)], optional, if None axes limits are set automatically
    "show_axes": bool, optional, whether to show the axes
    "offset_legend": float, optional, offset value for the legend
    "saving_path": str, optional, file path in which to save the plot. If None, the plot is displayed without saving
    "file_name_add": str, optional, additional string to add to the file name
    "transparent": bool, optional, transparent in case of saving
    "spatial_resolution": float, optional, spatial resolution for the scale bar
    "north_x_shift": float, optional, x-axis shift for the N of North
    "north_y_shift": float, optional, y-axis shift for the N of North
    "north_fontsize": float, optional, font size for the N of North
    "arrow_dx": float, optional, x-axis length of the North arrow
    "arrow_dy": float, optional, y-axis length of the North arrow
    "arrow_x_shift": float, optional, x-axis shift for the North arrow
    "arrow_y_shift": float, optional, y-axis shift for the North arrow
    "arrow_head_width": float, optional, width of the North arrow head
    "arrow_head_length": float, optional, length of the North arrow head

    --- return ---
    it shows the plot and optionally it could save
    """
    fig, ax = plt.subplots()

    # Regional shapefile
    region_shapefile.boundary.plot(color = 'Black', linewidth = 0.5, alpha = 0.6, ax = ax, label = "Administrative bounds")

    # Compute the maximum and minimum value if not specified
    if (vmin is None):
      vmin =  meteorological_raster[variable][time_step].min()
    if (vmax is None):
      vmax =  meteorological_raster[variable][time_step].max()

    # Meteorological map
    meteorological_map = meteorological_raster[variable][time_step].plot(ax=ax, cmap = cmap, add_colorbar=False, vmin = vmin, vmax = vmax)
    ax.set_title("")

    # Sensor network
    if (sensor_network_ds is not None):
      all_sensors_map = sensor_network_ds.plot(color = sensor_network_color, ax = ax,
                                               markersize = point_markersize, edgecolors = selected_sensors_edgecolor,
                                               linewidths = point_linewidths,
                                               label="ARPA water table sensors")

    # Catchment shapefile
    if(catchment_shapefile is not None):
      catchment_map = catchment_shapefile.boundary.plot(color = "Blue", linewidth = 0.1, alpha = 1, ax = ax, label="III level catchments")

    # Selected catchment shapefile
    if (selected_catchment is not None):
      selected_catch_map = selected_catchment.boundary.plot(color = selected_catch_color, ls = '--', linewidth = 0.6, alpha = 1, ax = ax, label="Selected catchment")

    # Selected sensors
    if (selected_sensors is not None):
      selected_sens_map = selected_sensors.plot(color = selected_sensors_color, ax = ax,
                                                markersize = point_markersize, edgecolors = selected_sensors_edgecolor,
                                                linewidths = point_linewidths,
                                                label = "ARPA selected sensors")

      # Automatic adjustment of sensor's label
      if (write_sensor_labels is not None):
          texts = []
          for x, y, label in zip(selected_sensors.geometry.x, selected_sensors.geometry.y, write_sensor_labels):
            texts.append(plt.text(x, y, label, ha='center', va='center' ,
                                  fontsize = 10, fontweight = "bold", fontstyle = "italic", color = "Black")) #, fontsize = 8

            aT.adjust_text(texts, force_text =(0.5, 1.5), force_explode=(0.1, 0.2), #, min_arrow_len = 5
                        force_static =(0.1, 0.2),
                        arrowprops=dict(arrowstyle="simple", linestyle = "--", color='dimgrey', lw=1.2))


    subtitle = str(plot_title) + " " + str(meteorological_raster.time[time_step].values.astype("datetime64[D]"))
    cbar_label = ''
    fig.suptitle(subtitle, x = 0.5, y = 0.925) # /OR/ x = (fig.subplotpars.right+0.15 + fig.subplotpars.left)/2
    fig.colorbar(meteorological_map, ax=ax, extend = 'both', shrink = 0.8, label = cbar_label)

    # Plot the scale of the raster
    if (spatial_resolution is not None):
      ax.add_artist(ScaleBar(dx=spatial_resolution, units="m", frameon = False, location = "lower right"))

    #
    if (map_bounds is not None):
      # For zooming onto a specific area different from the extent of the
      # meteorological_raster
      ax.set_xlim(map_bounds[0])
      ax.set_ylim(map_bounds[1])

    if (show_axes == False):
      ax.set_axis_off()

    else:
      ax.tick_params(axis='x', rotation=50)
      ax.set(xlabel = "Longitude [째E]", ylabel = "Latitude [째N]")

    fig.legend(bbox_to_anchor=(0.6, 0.125 + offset_legend))  #  (x, y, width, height)

    # Insert the North arrow
    ax.text(x=ax.get_xlim()[0]+north_x_shift, y=ax.get_ylim()[1]+north_y_shift, s='N', fontsize=north_fontsize)
    ax.arrow(ax.get_xlim()[0]+arrow_x_shift, ax.get_ylim()[1]+arrow_y_shift, arrow_dx, arrow_dy, length_includes_head=True,
          head_width=arrow_head_width, head_length=arrow_head_length, overhang=.1, facecolor='k')

    if (saving_path is not None):
      # A "_" is needed in case some string should be added to the file name
      if file_name_add != "":
          file_name_add = "_" + file_name_add

      plt.savefig(saving_path + variable + "_" + str(meteorological_raster.time[time_step].values.astype("datetime64[D]")) + file_name_add + '_map.png',
                    dpi=400, bbox_inches = 'tight', transparent = transparent)
    else:
      return plt.show()

"""# Time series and prediction plots"""

def plot_predictions_models(date, y_pred_list, y_error_list, title, point_size, axis,
                            model_colors, model_names, linewidth, alpha_error = 0.125,
                            eval_metric_value = None, eval_metric = "", scatter = False,
                            selected_models = None, sequence_first = True,
                            jump_between_sequences = 1,
                            step_ahead_range = None):
  """
  This function plots is meant for displaying the predictions of models either in case of saq2val or seq2seq
  You can choose to display in scatter or line+marker format
  In case of seq2seq 2 option ara available: "sequence_first True" lines link the point of a sequnces, while sequence are not linked;
       "sequence_first False" lines link element in the same position over all the sequences

  --- parameters ---
  "date": numpy array of np.datetime objects, dates to display on the x axes
  "y_pred_list", list of list, contains the prediction of multiple models, outer index: model, inner index: instance predicted
  "y_error_list", list of list, contains the quantity to display as shadow around the prediction, outer index: model, inner index: instance predicted
  "title": str, title of the plot
  "point_size": float, optional, marker size for the sensor points
  "axis": Axes object, axis on which to display the plot
  "model_colors": list of str, colors to be used for each modeld predictions'
  "model_names":, list of str, label of models
  "linewidth": float, width of the line linking points
  "alpha_error": float, transparency of the shadow around predictions
  "eval_metric_value": list of float, optional, contains the rmse of each model
  "eval_metric": list of str, optional, contains the name to be displaied of the rmse
  "scatter": bool, wheather to plot a scatter plot or a line plot
  "selected_models": list of int, optional, if some models have not to be displaied
  "sequence_first": bool, type of links in the case of seq2seq
  "jump_between_sequences": int, in the case of "sequence_first" True it set the number of sequence to not display
  "step_ahead_range": range of int, optional, in the case of "sequence_first" False set which element of every sequence to display

  --- return ---
  it outputs the plot object
  """

  if (selected_models == None):
    # some models to hide??
      selected_models = range(0,len(model_names))


  title = title + "\n"
  for i in selected_models:

      if (scatter == True):
      # do you want a scatter plot?

        if(len(date.shape)>1 and len(y_pred_list[i].shape)>1):
          # for seq2seq plot
          # more focus on sequence by sequence
          if (sequence_first == True):

              for j in range(0,date.shape[0], jump_between_sequences):
                a_sequence_dates = date[j,:]
                a_sequence_predictions = y_pred_list[i][j,:]
                label = "" if j<(list(range(0,date.shape[0], jump_between_sequences))[-1]) else model_names[i]

                for a_step_ahead in range(0,a_sequence_dates.shape[0]):
                  axis.scatter(a_sequence_dates[a_step_ahead],a_sequence_predictions[a_step_ahead], s = point_size, label = label, color = model_colors[i])

          # more focus on the same time step ahead
          else:
            color_per_step_ahead = sns.color_palette("Oranges_d", date.shape[1])
            if (step_ahead_range == None):
              step_ahead_range = range(0,date.shape[1])

            for j in step_ahead_range:
              dates_step_ahead = date[:,j]
              predictions_step_ahead = y_pred_list[i][:,j]
              label = model_names[i] + ":"
              #label += " time t + " + str(j) if j>0 else " time t"
              label += " time t + " + str(j+1)

              axis.scatter(dates_step_ahead,predictions_step_ahead, s = point_size, label = label, color =  color_per_step_ahead[j])

        else:
          # for seq2val plot
          axis.scatter(date,y_pred_list[i], s = point_size, label = model_names[i], color = model_colors[i])

      else:
        # or a line plot with marker "o"?
        if(len(date.shape)>1 and len(y_pred_list[i].shape)>1):
          # for seq2seq plot

          #plt.gca().set_prop_cycle(plt.cycler("color", color_per_step_ahead))
          if (sequence_first == True):

              for j in range(0,date.shape[0], jump_between_sequences):
                a_sequence_dates = date[j,:]
                a_sequence_predictions = y_pred_list[i][j,:]
                label = "" if j<(list(range(0,date.shape[0], jump_between_sequences))[-1]) else model_names[i]

                axis.plot(a_sequence_dates,a_sequence_predictions, marker = "o", ms = point_size, color = model_colors[i],  linewidth=linewidth, label = label)

          else:
            color_per_step_ahead = sns.color_palette("Oranges_d", date.shape[1])
            if (step_ahead_range == None):
              step_ahead_range = range(0,date.shape[1])

            for j in step_ahead_range:
              dates_step_ahead = date[:,j]
              predictions_step_ahead = y_pred_list[i][:,j]
              label = model_names[i] + ":"
              #label += " time t + " + str(j) if j>0 else " time t"
              label += " time t + " + str(j+1)

              axis.plot(dates_step_ahead,predictions_step_ahead, marker = "o", color = color_per_step_ahead[j], ms = point_size,  linewidth=linewidth, label = label)

        else:
          # for seq2val plot
          if (y_error_list == None):
            axis.plot(date, y_pred_list[i], marker = "o", label=model_names[i], color = model_colors[i], ms = point_size,  linewidth=linewidth)
          else:
            #axis.errorbar(date, y_pred_list[i][:,0], yerr=y_error_list[i][:,0], marker = "o", alpha = alpha_error, label=model_names[i], color = model_colors[i], ms = point_size,  linewidth=linewidth )
            axis.plot(date, y_pred_list[i], marker = "o", label=model_names[i], color = model_colors[i], ms = point_size,  linewidth=linewidth)
            axis.fill_between(date, y_pred_list[i][:,0]-y_error_list[i][:,0], y_pred_list[i][:,0]+y_error_list[i][:,0], color = model_colors[i], alpha = alpha_error)

      if (eval_metric_value != None):
        # ir rmse is provided is plotted for each model in a subtitle
        title = title + model_names[i] + " - "+ eval_metric +": " + str(round(eval_metric_value[i], 3)) + "\n"

  return title

def plot_ts_with_gaps(y,date, title, temp_freq = 'D', width = 5, height = 3,
                      ylabel_water_table = "Water Table Depth [m]",
                      precipitations = None,
                      date_precipitations = None,
                      xlabel = "Date",
                      scatter = False, y_lim = 0.15, point_size = 1.5,
                      linewidth = 0.2,
                      color_base_series = "tab:blue", label_base_series = "Water Table Depth",
                      label_precipitations = "Precipitations",
                      prec_color = "darkcyan",
                      zoom = None,
                      y_bottom_limit = None,
                      y_upper_limit = None,
                      reverse_axis = True,
                      sel_models = None, y_pred_list = None, y_error_list = None,
                      alpha_error = 0.125, model_names = None,
                      prediction_dates = None, sequence_first = True,
                      model_colors = None, eval_metric_value = None, eval_metric = "RMSE",
                      jump_between_sequences = 1,
                      step_ahead_range = None,
                      y_bottom_lim_offset = 0,
                      y_upper_lim_offset = 0,
                      xlimits = None,
                      xticks_freq='YS',
                      x_legend = 1.23,
                      y_legend = 0.5,
                      saving_path = None):

  """
  Function to plot a time series highliting missing periods. Multiple prediction could be displaied on the same axis of the main (ground truth) series. Optionally could show also the precipitation using another backgrounded axis

  "date" array with dates
  for seq2seq model provides "prediction_dates" array with date for each element of each sequence to be predicted
  e.g.
  title = file_name + " training/test set"


  --- parameters ---
  "y": array-like, values of the main series
  "date": array-like of np.datetime, dates of the corresponding "y"
  "title": str, title of the plot
  "temp_freq" : str, frequency of the x-axis
  "width", "height": float, width and height of the figure
  "ylabel_water_table": str, label for the main y axis
  "precipitations": array-like, optional, values of precipitation to be displaied using the second y-axis
  "date_precipitations": array-like of np.datetime, optional, dates of the corresponding "precipitations"
  "y_pred_list": list of list, contains the prediction of multiple models, outer index: model, inner index: instance predicted
  "y_error_list": list of list, contains the quantity to display as shadow around the prediction, outer index: model, inner index: instance predicted
  "xlabel": label for the x-axis
  "scatter": bool, wheather to plot a scatter plot or a line plot
  "y_lim": float, [0;1] factor by which y-axis limits are adjusted with respect to max and min
  "point_size": float, optional, marker size for the sensor points
  "linewidth": float, width of the line linking points
  "color_base_series": str, color for the "y" series
  "label_base_series": str, label for the "y" series
  "label_precipitations": str, label for precipitations
  "prec_color": str, color for the precipitations series
  "zoom": tuple of np.datetime, optional, if provided zoom between the date
  "y_bottom_limit": float, optional, manual bottom y limit in case "y" series is not provided
  "y_upper_limit": float, optional, manual upper y limit in case "y" series is not provided
  "reverse_axis": bool, where to reverse y axis
  "sel_models": list of int, optional, if some models have not to be displaied
  "y_pred_list", list of list, optional, contains the prediction of multiple models, outer index: model, inner index: instance predicted
  "y_error_list", list of list, optional, contains the quantity to display as shadow around the prediction, outer index: model, inner index: instance predicted
  "alpha_error": float, transparency of the shadow around predictions
  "model_names":, list of str, label of models
  "model_colors": list of str, colors to be used for each modeld predictions'
  "prediction_dates": array-like of np.datetime, optional, corresponding dates of the prediction
  "sequence_first": bool, type of links in the case of seq2seq
  "eval_metric_value": list of float, optional, contains the rmse of each model
  "eval_metric": list of str, optional, contains the name to be displaied of the rmse
  "jump_between_sequences": int, optional, in the case of "sequence_first" True it set the number of sequence to not display
  "step_ahead_range": range of int, optional, in the case of "sequence_first" False set which element of every sequence to display

  "y_bottom_lim_offset": float, offset for the y-axis bottom limit
  "y_upper_lim_offset": float, offset for the y-axis upper limit
  "xlimits": tuple np.datetime (start, end), optional, limits for the x-axis
  "xticks_freq": str, frequency of the x-ticks
  "x_legend": float, x-coordinate for the legend position
  "y_legend": float, y-coordinate for the legend position
  "saving_path" : str, optional, file path in which to save the plot. If None, the plot is displayed without saving

  --- return ---
  it shows the plot and optionally it could save
  """
  # compute all possible dates between the max and the min dates
  range_date = pd.date_range(date.min(), date.max(), normalize = True, freq=temp_freq, inclusive = "both")

  # set figure size
  fig, water_table_ax = plt.subplots(figsize = (width,height))


  ### Plot precipitations

  if(precipitations is not None):
    precipitation_ax = water_table_ax.twinx()
    precipitation_ax.set_ylabel('Total Precipitation [mm]')  # we already handled the x-label with ax1
    precipitation_ax.plot(date_precipitations, precipitations, color=prec_color, alpha = 0.25, marker = 'o', ms = point_size, linewidth = linewidth, label = label_precipitations)
    precipitation_ax.set_ylim((0, precipitation_ax.get_ylim()[1]))
    fig.tight_layout()

  # plot the Water Table time series
  # scatterplot or line?
  if (y is not None):
    if (scatter == True):
      water_table_ax.scatter(date, y, s = point_size, label = "Observations", color = color_base_series)

    else:
      water_table_ax.plot(date, y, marker = 'o', label = label_base_series , color = color_base_series, ms = point_size, linewidth = linewidth)

  # Set ticks on x axis
  if (xlimits==None):
    if (date.min().astype('datetime64[M]').astype(int) % 12 + 1 >= 9):
      first_xtick = np.array(date.min(), dtype='datetime64[Y]') + np.timedelta64(1, "Y")
      first_xtick = str(np.array(first_xtick, dtype='datetime64[D]'))
      x_bottom_limit = date.min() - np.timedelta64(60, "D")

    else:
      first_xtick = np.array(date.min(), dtype='datetime64[Y]')
      first_xtick = str(np.array(first_xtick, dtype='datetime64[D]'))
      x_bottom_limit = np.datetime64(first_xtick) - np.timedelta64(60, "D")

    if (date.max().astype('datetime64[M]').astype(int) % 12 + 1 >= 3):
      last_xtick = np.array(date.max(), dtype='datetime64[Y]') + np.timedelta64(1, "Y")
      last_xtick = str(np.array(last_xtick, dtype='datetime64[D]'))
      x_upper_limit = np.datetime64(last_xtick) + np.timedelta64(60, "D")

    else:
      last_xtick = np.array(date.max(), dtype='datetime64[Y]')
      last_xtick = str(np.array(last_xtick, dtype='datetime64[D]'))
      x_upper_limit = date.max() + np.timedelta64(60, "D")

  else:
    x_bottom_limit = xlimits[0]
    first_xtick = x_bottom_limit - np.timedelta64(30, "D")
    x_upper_limit = xlimits[1]
    last_xtick = x_upper_limit + np.timedelta64(30, "D")

  # Plot the predictions
  if (y_pred_list != None):
    try:
      if (prediction_dates == None):
        prediction_dates = date
    except ValueError:
      pass

    title =  plot_predictions_models(date = prediction_dates, axis = water_table_ax,
                               y_pred_list = y_pred_list,  y_error_list = y_error_list,
                               alpha_error = alpha_error, title = title,
                               point_size = point_size, model_colors = model_colors,
                               model_names = model_names, linewidth = linewidth,
                               eval_metric_value = eval_metric_value, eval_metric = eval_metric, scatter = scatter,
                               selected_models = sel_models, sequence_first = sequence_first,
                               jump_between_sequences = jump_between_sequences,
                               step_ahead_range = step_ahead_range)

  #### Axis limits
  water_table_ax.set_xticks(pd.date_range(first_xtick, last_xtick, normalize = True, freq=xticks_freq, inclusive = "both"))
  water_table_ax.tick_params(axis='x', rotation=50)
  water_table_ax.set(xlabel = xlabel, ylabel = ylabel_water_table)

  if (y is not None):
    if (reverse_axis is True):
      y_bottom_limit = y.max()+abs(y.max())*y_lim + y_bottom_lim_offset
      y_upper_limit = y.min()-abs(y.min())*y_lim + y_upper_lim_offset
    else:
      y_bottom_limit = y.min()-abs(y.min())*y_lim + y_bottom_lim_offset
      y_upper_limit = y.max()+abs(y.max())*y_lim + y_upper_lim_offset


  if (zoom!=None):
    water_table_ax.set_xlim((zoom[0], zoom[1]))
  else:
    water_table_ax.set_xlim((x_bottom_limit, x_upper_limit))



  # plot grey vertical lines for missing dates (missing data)
  if (len(range_date[[range_date[i] not in date for i in range(0,len(range_date))]])>0):
    water_table_ax.bar(range_date[[range_date[i] not in date for i in range(0,len(range_date))]],
                      bottom= y_bottom_limit if reverse_axis is False else y_upper_limit,
                      height = abs(y_bottom_limit-y_upper_limit),
                      width=7,
                      align='center', color = 'lightgrey',
                      label = "Water Table\nMissing Values", zorder = 0)

  water_table_ax.set_ylim((y_bottom_limit, y_upper_limit))

  ### Legend

  handles,labels = water_table_ax.get_legend_handles_labels()

  if(precipitations is not None):
    # retrive legends from the two axis
    handle_precipitation,label_precipitation = precipitation_ax.get_legend_handles_labels()
    handles = handles + handle_precipitation
    labels = labels + label_precipitation

  water_table_ax.legend(handles, labels, bbox_to_anchor =(x_legend,y_legend), loc = 'center right') #bbox_to_anchor =(0.5,-0.2), loc = 'lower center' center right

  # Grid and Title
  water_table_ax.grid(linestyle = '--', axis = 'x', color = 'black', alpha = 0.5)
  fig.suptitle(title, y = 1)

  # Save the figure
  if (saving_path!=None):
    plt.savefig(saving_path, bbox_inches = 'tight', dpi = 400)

  return plt.show()